\documentclass[a4paper,12pt]{thesis-ekf}
\usepackage[T1]{fontenc}
\PassOptionsToPackage{defaults=hu-min}{magyar.ldf}
\usepackage{fancyvrb,listingsutf8,xcolor,caption}
\usepackage{fancyhdr,amsthm,amsmath,amssymb,listings}
\usepackage{hyperref}
\usepackage[magyar]{babel}
\definecolor{dkgreen}{rgb}{0,.6,0}
\definecolor{dkblue}{rgb}{0,0,.6}
\definecolor{dkyellow}{cmyk}{0,0,.8,.3}
\lstset{
	inputencoding=utf8/latin2,
	language=php,
	basicstyle=\footnotesize\ttfamily,
	numbers=left,
	breaklines,
	postbreak=\hbox{$\color{red}\hookrightarrow\ $},
	xleftmargin=2cm,
	xrightmargin=2cm,
	backgroundcolor=\color{gray!10},
	frame=tlbr,
	framesep=3pt,
	keywordstyle=\bfseries\color{blue},
	commentstyle=\itshape\color{teal},
	stringstyle= \color{red},
	identifierstyle=\color{dkgreen},
	emph=[1]{php},
	emphstyle=[1]\color{black},
	emph=[2]{if,and,or,else},
	emphstyle=[2]\color{dkyellow},
	showstringspaces=false,
	keywords ={__halt_compiler, abstract, and, array,
		as, break, callable, case, catch, class,
		clone, const, continue, declare, default,
		die, do, echo, else, elseif,
		empty, enddeclare, endfor, endforeach, endif,
		endswitch, endwhile, eval, exit, extends,
		final, finally, for, foreach, function,
		global, goto, if, implements, include,
		include_once, instanceof, insteadof,
		interface, isset, list, namespace,
		new, or, print, private, protected, public,
		require, require_once, return, static,
		switch, throw, trait, try, unset, use, var,
		while, xor, yield,
	}
}
\theoremstyle{definition}
\newtheorem{definicio}{Definíció}[chapter]
\DeclareMathOperator{\tg}{tg}
\setlength{\headheight}{15pt}
\renewcommand{\lstlistingname}{kód}

\begin{document}
	\institute{Matematikai és Informatikai Intézet}
	\title{Webservice Menedzselhető Beléptetőrendszerhez}
	\author{Dombi Tibor Dávid\\Programtervező Informatikus}
	\supervisor{Dr. Tajti Tibor\\Egyetemi Adjunktus}
	\city{Eger}
	\date{2021}
	\maketitle
	\tableofcontents
	
	\chapter*{Bevezetés}\label{ch-ThesisIntro}
	Már egyetemi tanulmányaim előtt is legjobban a webes alkalmazások készítése foglalkoztatott, és ez az irány megmaradt végig a tanulmányaim során. Nem meglepő, hogy szakdolgozatomnak is ilyen témát választottam.
	Az utolsó két évemben elkezdtem komolyabban foglalkozni az IoT eszközökkel, és mivel rendkívül érdekesnek találtam a témát, szerettem volna belevenni a szakdolgozatomba. Így született meg ez a projekt.
	
	Így született meg ez a dolgozati téma: Egy menedzselhető, online felületen elérhető beléptetőrendszer prototípusa. A feladat rendkívül aktuális, hisz minden cég szabályozza, hogy ki léphet be a telephelyére, illetve valamilyen módon követi, hogy dolgozói mikor érkeztek és távoztak. Ez a rendszer mindkét feladatot automatizálja.
	
	A projekt elkészítése alatt nagy hangsúlyt fektettem a költséghatékonyságra illetve arra, hogy minél felhasználóbarátabb legyen, mindezt úgy, hogy minden szükséges szolgáltatást megvalósítson.
	
	A piacon számtalan hasonló rendszert találni, de ezek mind rendkívül komplexek és költségesek, többnyire csak a szolgáltató szerelői tudják beszerelni és üzemben tartani, valamint alig-, vagy egyáltalán nem szabhatók személyre. A célom az volt, hogy a projekt megoldást kínáljon ezekre a problémákra. Itt megjegyezném, hogy a dolgozat csak a webservice-al foglalkozik, a hardveres feladatokkal nem, viszont biztosít egy általános interfészt, amihez bármilyen hardver komponenst csatolhatunk.
	
	A technológia kiválasztásánál az volt a célom, hogy minél általánosabb, és minél könnyebben hozzáférhető legyen. Az online elérés megvalósítására számtalan módszer van, de a legegyszerűbb, ha eleve az egész rendszer egy szerveren fut, és valamilyen webtechnológiával van megvalósítva. Ez magában hordozza azt az előnyt is, hogy így a program bármilyen platformról elérhető. Bár a PHP népszerűsége sokat zuhant az elmúlt években\footnote{Forrás: \url{https://octoverse.github.com/}}, még mindig az egyik legdominánsabb nyelv, ha szerver oldali programozásról van szó\footnote{Forrás: \url{https://w3techs.com/technologies/details/pl-php}}, így erre esett a választásom. Továbbá, a Node.js vagy Go lang alapú technológiákhoz képest jóval egyszerűbb olcsó, vagy kisebb adatforgalom esetén akár ingyenes tárhely szolgáltatót találni.
	
	\chapter{Rendszer Bemutatása}\label{ch-SystemIntro}
		A rendszer rendkívül moduláris, így könnyen személyreszabható. De általánosítva, csupán egy webservice-ként üzemel, amihez Rest API-on keresztül csatlakozhatunk. Fontos megjegyezni, hogy a projekt nem arra szolgál, hogy programozási tudás nélkül beüzemelhető legyen, de nem is arra, hogy szolgáltatásként nyújtsuk. A projekt célja, hogy egy részletes, átfogó alapot adjon azoknak a fejlesztőknek, akik szeretnék a saját rendszerüket kifejleszteni.
		
		\section{Példa üzem}
		Legyen adott egy vállalkozás, ami szeretné a székhelyéül szolgáló iroda üpületet biztosítani, továbbá nyomonkövetni, hogy a dolgozok mikor érkeznek és mikor távoznak az épületből. A cég eleve mikrokontrollerekkel foglalkozik, így a hardware-es kiépítés nem jelent problémát. Ebben az esetben nyúlhatnak olyan projektekhez, mint a jelen szakdolgozati munka.
		
		\emph{\nameref{sc-Installation}} után a program egy egyszerű Rest API szolgáltatás. A kommunikáció JSON formátumban történik. 
		
		Az hardware-es megvalósításra javaslat a \ref{ch-Hardware} fejezetben található. Megvalósítástól függetlenül, a zárnak el kell küldenie a Webservice-nek a saját azonosítóját, illetve a dolgozó azonosítóját (ez lehet példáúl az a szám amit egy RFID kártyáról leolvasott). A zárnak azonosítania kell magát. Ennek mikéntjét az \emph{\nameref{sc-auth} (\ref{sc-auth})} fejezetben részlet\-ezem. A webservice az ismert szabályok alapján eldönti, hogy az adott dolgozó ebben az időpontban használhatja-e a zárat, majd a döntésével válaszol a zárnak. Ha telepítettük a napló modult, akkor a döntés naplózásra kerül.
		
		Az admin felületen követhetjük, mind a rendszerben történt eseményeket, mind a zárak használatát.
		
		\section{Telepítés}\label{sc-Installation}
		 A projekt letölthető a saját github repository-jából. Az alkalmazás futtatásához szükségünk lesz egy PHP szerverre (nginx, Apache, lighttpd, stb.), illetve egy Laravel által támogatott adatbázis szerverre (MySQL, Postgres, SQLite, vagy SQL Server). Ezek lehetnek a felhőben, vagy egy lokális szerveren. 
		 
		 Fontos megjegyezni, hogy ha az alkalmazás privát hálózaton működik, akkor kívülről nem-, vagy csak bonyolult hálózati konfigurációk után érjük azt el. Belső hálózaton természetesen továbbra is működik minden.
		
		Amennyiben a példa vállalkozásunk nem tervezi tovább fejleszteni az alkalmazást, csupán használni, akkor a beüzemelés csak a Composer csomagok telepítéséből, majd a használni kívánt funkciókat biztosító modulok telepítéséből áll. Ehhez érdemes a megfelelő Artisan parancsot használni:
		
		\begin{Verbatim}
composer install         # A Composer csomagok telepítéséhez
php artisan acs:install  # A telepítő varázsló indításához
		\end{Verbatim}
		
		Ez elindítja a mellékelt \nameref{ssc-install-wizard}t. A telepítés végeztével a projekt használatra készen áll. Amennyiben szeretnénk, innen tovább fejleszthetjük.
		
		\subsection{Telepítő varázsló}\label{ssc-install-wizard}
		A \verb|php artisan acs:install| parancssal elindított telepítő program végig vezet minket az alkalmazás konfigurációján.
		
		Elsőként arra kell válaszolnunk, hogy tovább szeretnénk-e fejleszteni a projektet, vagy csak használni szeretnénk. Mindkét esetben az alkalmazás alapvető adatainak, majd az adatbázis hozzáférési adatainak megadásával kell kezdjük a konfigurációt.
		
		A választott adatbázis szerverünkön létre kell hozzunk egy adatbázist amit majd később használ a rendszer, de ezt nem kell feltöltsük táblákkal, adatokkal, illetve teljesen mindegy milyen karakter kódolást választunk. Ezeket a Laravel migration rendszere fel fogja tölteni nekünk. 
		
		A következő kérdés a Git konfiguráció. Itt kiválaszthatjuk, hogy kapcsolódjunk-e egy már meglévő repository-hoz, hozzunk létre egy teljesen újat, vagy akár át is ugorhatjuk ezt a lépést, ha más verzió kezelőt szeretnénk használni, vagy nincs is szükségünk rá. 
		
		Amennyiben a fejlesztői módot választottuk telepítés során, úgy további kérdéseket tesz fel nekünk a program. Itt választhatjuk ki, hogy szeretnénk-e CI/CD eszközöket konfigurálni. Ha igen a program végig vezet minket a Github Actions és a Heroku beállításain. (Lásd: \nameref{ssc-CiCd}) Természetesen bármelyik átugorható, ha nincs rá szükségünk. Ha valamilyen más ilyen szolgáltatást szeretnénk használni, akkor érdemes egyszerűen kihagyni ezt a lépést.
		
		Ezután következik a modulok kiválasztása. Egyszerűen válasszuk ki azokat a funkciókat, amiket szeretnénk használni, és automatikusan telepítésre kerülnek. Ha egy modul további konfigurációt igényel (pl.: email szolgáltatás) akkor azt a következő lépésben tudjuk konfigurálni.
		
		Fejelsztői módban minden modulnál kiválaszthatjuk, hogy hová telepítse az adott modult: A \verb|vendor| mappába, vagy a \verb|project-root| mappába. A \verb|vendor| mappába történő telepítés akkor hasznos, ha egy modulra szükségünk van, de nem szeretnénk tovább fejleszteni vagy módosítani rajta. Ilyenkor egyszerű composer csomagként települ és az eredeti repository-val együtt frissül.\\*
		Azonban, ha szeretnénk módosítani az adott modulon, akkor válasszuk a \verb|project-root| mappát, mint telepítés helye. Ezek a modulok a projekt fájljaink mellé kerülnek és lehetőségünk van saját csomagként publikálni őket.
		
		Végezetül némely szolgáltatás esetén érdemes újra indítani azt (pl. Apache). A programunkat ezután elérjük a beállított címen.
		
		\subsection{Tesztelés és CI/CD}\label{ssc-CiCd}	
		A projekt tartalmazza a PHP Unit csomagot, amivel könnyedén tudunk unit teszteket írni. Tesztjeink többsége azonban magasabb szintű teszt lesz, így ezeket fejtem ki bővebben.
		
		Feature teszt írásához örököltessük a teszt osztályunkat a \verb|HttpTest| absztrakt osztálytól. Ekkor elérjük a Laravel beépített Http test funkcióit, illetve további segéd fügvényeket. Ezeknek előnye, hogy a "beszédes" függvényekkel a tesztünk könnyen olvasható lesz.
		
\begin{lstlisting}
<?php

namespace Tests\Feature;

use Tests\HttpTest;
use Utils\StatusCodes;

class ExampleTest extends HttpTest
{
  public function testApiRequest()
  {
    $response = $this->actingAs(Admin())
                     ->postJson(
                       '/api/user',
                       ['name' => 'John']
                     );

    $response->assertStatus(StatusCodes::CREATED)
             ->assertJson(['created' => true]);
  }
}
\end{lstlisting}

		A Console Test lényegében Feature teszt, ami a saját Artisan parancsainkat hivatott ellenőrizni. Erre nem írtam külön segéd osztályt, a teszt osztályunkat örököltessük a \verb|TestCase| osztálytól (Ez a Laravel beépített teszt facade osztálya). Kiemelnék egy példát a Laravel dokumentációból:
		
\begin{lstlisting}[caption={Egy példa Artisan parancs}]
/** Az Artisan parancs: **/
Artisan::command('question', function () {
  $name = $this->ask('What is your name?');

  $language = $this->choice('Which language do you prefer?', [
    'PHP',
    'Ruby',
    'Python',
  ]);

  $this->line('Your name is '.$name.' and you prefer '.$language.'.');
});
\end{lstlisting}

\begin{lstlisting}[caption={A fenti parancs tesztelése}]
/** Test a console command. **/
public function test_console_command()
{
  $this->artisan('question')
       ->expectsQuestion('What is your name?', 'Taylor Otwell')
       ->expectsQuestion('Which language do you prefer?', 'PHP')
       ->expectsOutput('Your name is Taylor Otwell and you prefer PHP.')
       ->doesntExpectOutput('Your name is Taylor Otwell and you prefer Ruby.')
       ->assertExitCode(0);
}
\end{lstlisting}

		Végül pedig az adatbázis tesztekhez elérhető egy \verb|DatabaseTest| absztrakt osztály, melynek célja és használata is hasonló, mint az \verb|HttpTest| osztálynak, csupán más függvényeket tesz elérhetővé. Kiemelném, hogy mind az \verb|HttpTest| mind a \verb|DatabaseTest| a Laravel beépített \verb|TestCase| osztályától örököl, tehát a keretrendszer beépített függvényei mindenkor rendelkezésünkre állnak.
		
		Azért, hogy a felhasználó minél hamarabb megkapja a programját, illetve, hogy a hibák minél hamarabb kiderüljenek és minél hamarabb orvoslhatók legyenek, a modern programozási feladatok legnagyobb része használ valamilyen Continuous Integration-t és Continuous Development-et biztosító szolgáltatást. Amennyiben nagyobb mértékben szeretnénk tovább fejleszteni a projektet, mindenképpen érdemes elgondolkodnunk ezek használatán.
		
		A projekt majdnem teljesen konfigurálva érkezik Github actions (CI) illetve Heroku (CD) számára, így elég a projekt specifikus adatokat megadni (felhasználó nevek, API kulcsok, stb.) és már is használhatóak ezek a technológiák is. Hogy pontosan mit kell beállítanunk, az attól függ, hogy milyen szolgáltatást veszünk igénybe, de a környezeti változókat minden esetben fel kell vinnünk (Adatbázis hozzáférés, levelező szerver hozzáférés, stb.).
		
	\chapter{API kommunikáció}
		A webservice egy RESTful API-t biztosít, hogy a saját eszközeink könnyedén tudjanak kommunikálni vele. Az erőforrásaink ebben az esetben a \emph{zárak}, \emph{dolgozók}, \emph{ezek csoportjai}, valamint a \emph{szabályok}. Ezekre a Bread műveleteket (\ref{sc-bread}) (Browse, Read, Edit, Add, Delete) úgy tudjuk alkalmazni, hogy az API megfelelő végpontjait érjük el, megfelelő HTTP metódussal (GET, POST, PUT/PATCH, DELETE).
		
		Az összes végpont, és azok válaszainak a leírását egy swagger fájlban megadtam, és a szakdolgozathoz csatoltam, így ezeket itt nem fejtem ki.
		
		\section{BREAD vagy CRUD műveletek}\label{sc-bread}
			Amikor az erőforrásokkal végezhető műveletekről beszélünk gyakran használjuk a CRUD vagy BREAD mozaikszavakat. A CRUD a \emph{Create, Read, Update, Delete} szavak rövidítése. Gyakran használják mivel közvetlenül megfeleltethető mind az SQL nyelv metódusainak, mind az HTTP metódusainak:
			
			\begin{table}[h!]
				\centering
				\begin{tabular}{|c|c|c|}
					\hline
					\multicolumn{1}{|c|}{\textbf{SQL}} & \textbf{CRUD} & \textbf{HTTP} \\ \hline
					INSERT & CREATE & POST \\ \hline
					SELECT & READ & GET \\ \hline
					UPDATE & UPDATE & PUT / PATCH \\ \hline
					DELETE & DELETE & DELETE \\ \hline
				\end{tabular}
				\caption{HTTP, SQL, és CRUD műveletek megfeleltetése}
				\label{table:http-sql-crud}
			\end{table}
		
			Viszonylag újabb megközelítés, a BREAD (Browse, Read, Edit, Add, Delete). Ez lényegében megegyezik a CRUD metódusokkal, annyi különbséggel, hogy a BREAD külön veszi azt a metódust, amikor minden erőforrásra kíváncsiak vagyunk (Indexelés), illetve azt a metódust amikor csak egy erőforrás részleteire vagyunk kíváncsiak. Ez azért előnyösebb a számomra, mert ezek jobban megfeleltethetők a Laravel Controller metódusainak. Ha ezeket is meg szeretnénk feletetni egymással, akkor a táblázatunk a következőre módosul:
	
			\begin{table}[h!]
				\centering
				\begin{tabular}{|c|c|c|c|c|}
					\hline
					\textbf{SQL} & \textbf{CRUD} & \textbf{HTTP} & \textbf{BREAD} &\textbf{Laravel Controller} \\ \hline
					SELECT & READ & GET & BROWSE & INDEX \\ \hline
					SELECT & READ & GET & READ & SHOW \\ \hline
					UPDATE & UPDATE & PUT / PATCH & EDIT & UPDATE \\ \hline
					INSERT & CREATE & POST & ADD & STORE \\ \hline
					DELETE & DELETE & DELETE & DELETE & DESTROY \\ \hline
				\end{tabular}
				\caption{HTTP, SQL, CRUD műveletek a BREAD-hez képest}
				\label{table:http-sql-crud-bread}
			\end{table}	
		
		\section{HTTP metódusok}
			Az HTTP szabvány úgynevezett metódusokat (hivatalosan \emph{methods}, de szokás \emph{verb}-ként is hivatkozni rájuk) definiál nekünk, hogy ezzel közöljük a szerverrel, hogy mi a szándékunk az URI-ben megnevezett erőforrással. Vegyük példáúl a \verb|worker| erőforrást. Ebben az esetben az implementált metódusok:
		
			\subsection{GET}
				Ezen HTTP metódussal két funkció is elérhető. Ha nem definiáljuk hogy pontosan melyik rekordot (példákban: melyik dolgozót) szeretnénk részletezni egy erőforráson belül, akkor vissza kapjuk az összes ezen erőforrásban tárolt rekordot (tehát az összes dolgozót). A Laravelben megegyezés szerint ez a függvény az \verb|index()|.
\begin{lstlisting}[caption={Példa a BROWSE metódusra}][language=json]
Request:
 GET www.example.com/worker
 
Response:
 [
   {
     "name": "Shelia Lakin",
     "created_at": "2021-06-30T12:09:20.478Z",
     "phone": "938-402-3157 x810",
     "id": "4b3403665fea6"
   },
   {
     "name": "Whitney McClure",
     "created_at": "2021-06-18T05:26:38.641Z",
     "phone": "(765) 538-9079",
     "id": "4b3407665bcd5"
   }
]
\end{lstlisting}
				
				Amennyiben az URI-ben specifikáljuk, hogy melyik rekordot szeretnénk elérni, úgy részletes infókat kapunk arról (tehát egy dolgozó adatait kapjuk vissza). Laravelben ez a \verb|show()| függvény, konvenció szerint.
\begin{lstlisting}[caption={Példa a READ metódusra}][language=json]
Request:
 GET www.example.com/worker/4b3403665fea6
 
Response body:
 {
   "name": "Whitney McClure",
   "created_at": "2021-06-18T05:26:38.641Z",
   "last_logged_in": "2021-06-30T05:26:38.641Z",
   "phone": "(765) 538-9079",
   "id": "4b3407665bcd5",
   "teams": [
     {
       "id": 1,
       "name": "Team1"
     },
     {
       "id": 2,
       "name": "Team2"
     }
   ]
 }
\end{lstlisting}

			\subsection{POST}
				Ezzel a metódussal új erőforrást hozhatunk létre. Ehhez a kérésünk törzsében meg kell adnunk minden szükséges tulajdonságot, illetve az opcionális tulajdonságokat vagy megadjuk, vagy nem. Ezen tulajdonságok sorrendje tetszőleges. Kiemelném, hogy a kérésünk törzsében lehet egy JSON objektum vagy egy tömb, ami több objektumot is tartalmazhat. Ha ez utóbbi áll elő, akkor a webservice felveszi nekünk az összes rekordot. Ez a felvétel tranzakció szerűen működik, tehát ha bármelyik adatfelvitel sikertelen, akkor az összes visszavonásra kerül. Természetesen ehhez a művelethez elég az erőforrást azonosítanunk, nem szükséges egy konkrét rekord azonosítóját megadni az URI-ben. Ha az adatfelvitel sikeres a szerver 201-es státuszkóddal válaszol
				
			
		\section{JWT}
			...
		\section{Azonosítás}\label{sc-auth}
			...
	\chapter{Rest Service}
		...
		\section{Laravelről}
			...
			\subsection{Provider-ek}
				...
		\section{Jogosultságok}
			...
		\section{Erőforrások}
			...
		\section{Szabályok}
			...
		
	\chapter{Admin Service}
		A beléptetőrendszer menedzselését célszerű egy admin felületen megtenni. Az alkalmazás alapból nem rendelkezik semmilyen felülettel, csak az API-on keresztül kommunikálhatunk vele. A szakdolgozatban mellékeltem egy Angular alapú Adminisztrátori felületet, mely teljesen függetlenül, SPA formában működik. Ebből az következik, hogy el lehet helyezni egy független szerveren, de persze futhat ugyan azon a szerveren is, ahol a webservice fut.
		
		Az admin felület elsősorban demonstráció miatt került be, a szakdolgozat továbbra is a webservice-ra fókuszál
	\chapter{Adminisztrátori felület}\label{ch-Admin}
		\section{Kezdőlap}
			...
		\section{Profil műveletek}
			...
		\section{CRUD műveletek}
			...
		\section{Jogosultságok kezelése}
			...
		\section{Szabályok felvitele}
			...
	\chapter{Hardveres megvalósítási javaslat}\label{ch-Hardware}
		\section{Eszközök}
			...
		\section{Szoftver}
			...
\end{document}